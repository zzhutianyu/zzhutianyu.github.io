<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://blog.zhuxingzhao.com</id>
    <title>诸天域</title>
    <updated>2021-06-13T16:09:05.663Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://blog.zhuxingzhao.com"/>
    <link rel="self" href="https://blog.zhuxingzhao.com/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://blog.zhuxingzhao.com/images/avatar.png</logo>
    <icon>https://blog.zhuxingzhao.com/favicon.ico</icon>
    <rights>All rights reserved 2021, 诸天域</rights>
    <entry>
        <title type="html"><![CDATA[大中型游戏运维思考]]></title>
        <id>https://blog.zhuxingzhao.com/post/da-zhong-xing-you-xi-yun-wei-si-kao/</id>
        <link href="https://blog.zhuxingzhao.com/post/da-zhong-xing-you-xi-yun-wei-si-kao/">
        </link>
        <updated>2021-06-12T14:03:29.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>笔者从20年开始参与某大中型手游运维工作，以及在组内其他游戏运维经验的见解<br>
粗略描写，后续补充</p>
</blockquote>
<h2 id="叙述">叙述</h2>
<h2 id="游戏运维面对的挑战">游戏运维面对的挑战</h2>
<h3 id="架构复杂多样化">架构复杂多样化</h3>
<p>游戏架构大多架构复杂，为了应对海量的用户，架构上都是高度集群以及分布式</p>
<h3 id="模块数量多">模块数量多</h3>
<p>随着游戏生命周期的不断延续，其运营的过程中，会随着运营的发展不断增加模块来支持不同的玩法和活动，我所接触的某fps手游就多达100以上的游戏进程模块。</p>
<h3 id="发布频繁">发布频繁</h3>
<p>游戏运营过程中，必然随着运营所带来的各种活动和策划的玩法修改，必然会有不断的频繁的发布。这就要求运维必须有能力支持这种频繁的发布，特别是面对复杂游戏业务的时候。</p>
<h3 id="有状态过多">有状态过多</h3>
<p>游戏一般为了保障用户体验，大部门的游戏模块都是有状态设计，这就导致了不能像web应用可以使用大规模无状态应用的发布方式。对于有状态的应用的发布，必然慎之又慎，避免用户数据丢失导致的用户体验和用户投诉。</p>
<h3 id="不停机发布的挑战">不停机发布的挑战</h3>
<p>为了保障用户的良好体验，越来越多的游戏都开始建设了不停服发布的发布流程，就是为了保证玩家体验不中断。但是不停服就给游戏架构和运维带来了挑战，如何建设一个稳定的不停服发布流程是需要运维和开发需要不断沟通设计的。</p>
<h2 id="准备阶段">准备阶段</h2>
<p>本章阐述游戏的基础准备内容，运维人员应该在游戏正式发布之前建设好以下内容，在随着游戏运营的不断发展进行调整。</p>
<h3 id="机器资源容量评估">机器资源容量评估</h3>
<p>机器资源容量评估是一个非常重要的准备工作，我们对于容量评估必须保证合理以及冗余。</p>
<ul>
<li>模块数量</li>
<li>单模块承载容量</li>
<li>机器非游戏进程的以外其他进程的消耗</li>
<li>适量的冗余</li>
<li>我们必然保证模块从前往后应该逐渐冗余，上游模块压垮下游模块</li>
</ul>
<p>容量评估完成，必须沉淀为标准公式即</p>
<p>当前预计容量 / 单模块单机（需要明确机型）容量 = 机器数量</p>
<p>完成标准公式是为之后的标准化流程建设准备</p>
<h3 id="cdn容量评估">CDN容量评估</h3>
<p>CDN是游戏成本的大头，我们需要考虑每次发布所需要的CDN容量，来进行必要的容量准备，以及可以的成本优化。常见的成本优化方法</p>
<ul>
<li>预下载</li>
<li>边缘CDN</li>
<li>P2P下载</li>
</ul>
<h3 id="成本核算">成本核算</h3>
<p>运维需要对游戏消耗成本的高度敏感，我们需要了解游戏成本方方面面，明确占比，在必要的时候，需要进行成本优化，将不必要的成本优化掉，减少必要的浪费。</p>
<ul>
<li>CDN</li>
<li>机器成本</li>
<li>储存成本</li>
<li>营销机器成本</li>
</ul>
<h3 id="机器初始化准备">机器初始化准备</h3>
<p>我们需要梳理机器所必要的一些初始化的准备</p>
<ul>
<li>网络内核参数调优</li>
<li>运营目录结构</li>
<li>crontab定时作业</li>
<li>必要的非游戏进程（监控，管控，数据上报）</li>
</ul>
<h3 id="模块划分">模块划分</h3>
<p>我们需要按模块合理划分游戏进程，这一步一般需要和开发进行沟通考虑。运维侧最好有相关的元数据管理系统，沉淀模块信息。</p>
<h2 id="统一的基础设施建设">统一的基础设施建设</h2>
<p>一个统一的基础设施是非常有必要的，避免人员迭代以及不规范的一些操作导致线上环境不断发散腐烂。</p>
<h3 id="基于虚拟机或物理机器到运维基础设施建设">基于虚拟机或物理机器到运维基础设施建设</h3>
<h4 id="统一的机器镜像">统一的机器镜像</h4>
<p>我们最好事先准备一个统一的机器镜像，里面安装了必要的软件和去除不必要的东西。</p>
<h4 id="统一的脚本">统一的脚本</h4>
<p>我所见到很多老运维对于脚本管理简直是混乱不堪，线上存在许许多多的脚本，而不明确每个脚本的作用。我们必须建设统一的cli工具作为统一运维console工具的入口。虽然shell是运维的强大工具。在这里我推荐的是go来构建统一的cli工具。</p>
<ul>
<li>go直接打包成可执行二进制，不分散文件</li>
<li>静态语言的特性保证了工具的质量</li>
<li>不需要关心机器的运行环境</li>
</ul>
<p>统一的cli工具的优势</p>
<ul>
<li>唯一的操作入口</li>
<li>沉淀工具脚本</li>
<li>各个环境版本一致</li>
</ul>
<h4 id="统一的配置">统一的配置</h4>
<p>上面我们说了建设统一cli工具，那我们的环境配置也需要统一的配置，通过统一的环境配置，我们可以在不同的环境通过不同的环境配置就可以达到不同环境一个脚本一个操作，而不必不同环境单独书写不同的脚本。操作统一，避免事故。推荐yaml形式作为配置。</p>
<h4 id="版本化的管理">版本化的管理</h4>
<p>我们以上的统一的建设，都必须要做到一个要求，就是版本化的管理。我们可以使用版本管理软件将以上建设纳管。 我们就可以建设一套基础设施管理的流程。我们可以通过软件开发的方法保证我们的基础设施的质量。 我们遵循gitflow或者github flow的方式，来对我们的基础设施进行发布管理 然后通过CD工具自动发布到全部的机器，保证全部环境的统一。</p>
<h3 id="基于容器的基础设施建设">基于容器的基础设施建设</h3>
<p>随着业务上云的趋势。我们也在探索容器在游戏领域的探索。</p>
<h4 id="k8s集群的基础设施">k8s集群的基础设施</h4>
<p>首当其冲就是k8s集群的管理，这里建议的是最好是托管到各个云平台的容器服务，自建k8s集群需要投入必要的容器运维人员。</p>
<h4 id="helm配置管理">helm配置管理</h4>
<p>容器的配置管理自然是helm，我们需要根据游戏架构的设计，进行对应template的文件编写。</p>
<h2 id="流程管理">流程管理</h2>
<p>流程是一个游戏运营生命周期非常重要的一环，最好是有一个流程编排系统，并且打通相关的系统。方便我们进行流程的编排和自动化。 我们的要求是 - 不需要人的地方，由工具操作 - 需要人的地方，工具辅助人操作</p>
<h3 id="虚拟机或物理机">虚拟机或物理机</h3>
<h4 id="发布流程">发布流程</h4>
<p>一个完整的发布流程一般有以下部分</p>
<ul>
<li>当前版本容量评估阶段</li>
<li>机器准备阶段</li>
<li>机器初始化阶段</li>
<li>产物发布</li>
<li>进程发布</li>
<li>检查</li>
<li>发布完成</li>
</ul>
<h4 id="不停服发布">不停服发布</h4>
<p>不停服发布需要游戏架构支持，一般的不停服发布主要有以下方式</p>
<ul>
<li>
<p>两个版本两批机器</p>
<ul>
<li>发布不影响上一版本</li>
<li>需要版本发布期间需要两部容量的机器</li>
</ul>
</li>
<li>
<p>机器分批发布</p>
<ul>
<li>模块需要数量需要为2n以上，避免分批发布过程中，出现单点</li>
<li>需要架构支持玩家下线不在路由导向另一批机器</li>
<li>存在一定的用户体验影响，强制引导另外一批机器入口</li>
</ul>
</li>
</ul>
<h4 id="停机发布">停机发布</h4>
<p>停机发布只要遵循正常发布流程即可，需要运营侧发布正常的停机公告。</p>
<h4 id="容量调整">容量调整</h4>
<p>在游戏运营过程中，我们不可避免，某次活动导致玩家人数上升，需要扩容机器，某段时间玩家人数下降，导致缩容机器。</p>
<h4 id="扩容流程缩容流程">扩容流程&amp;缩容流程</h4>
<p>游戏进程一般分局内局外进程。所以正常的两块的机器是不一样的。</p>
<ul>
<li>
<p>扩容流程</p>
<ul>
<li>机器准备</li>
<li>分发对应游戏版本产物</li>
<li>启动进程</li>
<li>检查</li>
<li>扩容完成</li>
</ul>
</li>
<li>
<p>缩容</p>
<ul>
<li>等待玩家下线（需要进程支持配置模块不接受新玩家）</li>
<li>停止进程</li>
<li>检查</li>
<li>机器下线</li>
</ul>
</li>
</ul>
<h4 id="故障替换流程">故障替换流程</h4>
<ul>
<li>替换流程
<ul>
<li>新机器准备</li>
<li>分发对应游戏版本产物到新机器</li>
<li>启动进程</li>
<li>检查</li>
<li>切换</li>
<li>替换完成</li>
<li>下线故障机器</li>
</ul>
</li>
</ul>
<h2 id="可观测性建设">可观测性建设</h2>
<p>在游戏运营过程中，我们必须建设好业务的可观察性，避免故障发生，没有及时的发现，以及方便的排除各种问题。</p>
<h3 id="必要关键链路">必要关键链路</h3>
<ul>
<li>登录</li>
<li>注册</li>
<li>在线</li>
<li>付费</li>
<li>对局</li>
</ul>
<h3 id="指标">指标</h3>
<h4 id="业务指标">业务指标</h4>
<ul>
<li>在线指标</li>
<li>登录指标</li>
<li>注册指标</li>
<li>付费指标</li>
</ul>
<h4 id="机器指标">机器指标</h4>
<ul>
<li>cpu</li>
<li>内存</li>
<li>磁盘</li>
<li>网络</li>
</ul>
<h3 id="日志">日志</h3>
<p>需要建设必要的分布式日志系统，以及统一的日志规范。 可以基于ELK开源方案构建日志系统。 或者云厂商的日志方案</p>
<h3 id="分布式跟踪">分布式跟踪</h3>
<p>游戏模块后台链路复杂，最好游戏支持从客户端开始的分布式跟踪协议,这里建议的是opentelemetry ，最好支持染色机制，排查特定的链路问题。</p>
<h3 id="告警建设">告警建设</h3>
<p>建设好可观测相关的内容之后，我们就可以建设稳定的监控策略</p>
<ul>
<li>各种环境的策略</li>
<li>策略的干系人</li>
<li>策略的阈值</li>
<li>策略的对象 随着建设的不断完善，我们也可以建设智能监控相关的能力。</li>
</ul>
<h2 id="运维需要的相关工具">运维需要的相关工具</h2>
<ul>
<li>CMDB平台</li>
<li>作业系统</li>
<li>文件分发系统</li>
<li>版本管理系统</li>
<li>流程编排</li>
<li>可观察性平台</li>
<li>文档系统</li>
</ul>
<h2 id="游戏数据分析">游戏数据分析</h2>
<p>我们需要建设游戏领域的数据场景模型</p>
<ul>
<li>在线场景</li>
<li>登录场景</li>
<li>注册场景</li>
<li>付费场景</li>
<li>网络场景</li>
<li>客户端路径</li>
<li>服务端路径</li>
<li>游戏地图分析</li>
<li>客户端设备分析</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[领域驱动设计思考]]></title>
        <id>https://blog.zhuxingzhao.com/post/ling-yu-qu-dong-she-ji-si-kao/</id>
        <link href="https://blog.zhuxingzhao.com/post/ling-yu-qu-dong-she-ji-si-kao/">
        </link>
        <updated>2021-03-28T10:26:53.000Z</updated>
        <content type="html"><![CDATA[<h3 id="软件设计模式的发展">软件设计模式的发展</h3>
<p>软件设计模式一直在不断的发展和实践过程中，我们一直不断的总结和思考什么样的软件设计模式适合实际的项目开发。<br>
从上个世纪以来，从直接特定硬件上构建软件，到操作系统的诞生，我们的软件开发人员从此从繁琐的底层操作抽离出来，从而可以吧中心放到了实际功能的实现，让我们不在关注底层的细节。这正是操作系统所带来的。从而带来的思想是，我们可以通过分层去处理问题。<br>
<img src="https://blog.zhuxingzhao.com/post-images/1616927448754.jpg" alt="" loading="lazy"><br>
随之而来的带来带问题是，在不同的操作系统之间，我们的应用软件带来了互相不兼容的问题，我们的一份代码不能在这些不同的操作系统的之间实用，那怎么办呢，我们继续使用上面的思考办法，我们继续对操作系统进行隔离，我们构建一套虚拟机，来运行我们的代码。这就是<code>java</code>，它所宣称的思想就是一次编译，各个平台都能运行。<br>
所以分层的思想是一个相当重要的思想。当我们将复杂问题都给分层处理之后，随后在应用软件开发中，我们也随之面对着在应用软件开发中所遇到的问题，我们的软件架构也需要在这些问题中进行着设计。那么我们对实际问题对分析之后得出，在实际应用程序之中，我们对数据流转过程的分析，我们得出了一种新的软件设计模式，这就是<code>mvc</code>模式。<br>
<img src="https://blog.zhuxingzhao.com/post-images/1616927463569.jpg" alt="" loading="lazy"><br>
在面向用户的应用程序中，对其中的交互过程，抽象成了上图的方式，通过<code>controller</code>来处理逻辑，<code>model</code>来处理数据，<code>view</code>来展示，在<code>web</code>1.0的时代的时候，<code>view</code>层主要在后端处理，而在2.0的时代来临之后，在我们将<code>view</code>过渡到前端之后，后端天然的变成了<code>cm</code>模式了。<br>
随着时间的前进，我们继续探索者更加符合当代的软件设计模式，我们随之又提出了<code>mvvm</code>的开发方式<br>
<img src="https://blog.zhuxingzhao.com/post-images/1616927475525.jpg" alt="" loading="lazy"><br>
通过上述模型有助于将图形用户界面的开发与业务逻辑或后端逻辑（数据模型）的开发分离开来，前后端的人员明确的分工开始了。<br>
随着当代软件的复杂度和规模不断扩大，我们需要一些更加符合实际的设计模式来帮助我们完成我们的软件设计以达到良好的工程效率以及代码质量。<code>TDD</code>和<code>DDD</code>设计相继被实践出来。在<code>TDD</code>的方法下，我们在<code>红绿</code>重构之间不断完善我们的代码功能和逻辑以达到良好的项目质量。<br>
<img src="https://blog.zhuxingzhao.com/post-images/1616927489686.jpg" alt="" loading="lazy"><br>
而<code>DDD</code>更是在面向对象的方法下面，更加高度的提出了一种对整个项目更加有益的设计思想。</p>
<h3 id="什么是领域驱动设计">什么是领域驱动设计</h3>
<p>领域驱动设计（Domain Driven Design)，在面对对象的基础上提出了一种更加有效的设计思想，让我们在开发以及项目管理上，能得到更好的优势。<br>
在一个对开发人员完全陌生的一个领域时，我们需要让开发人员理解这个领域的知识才能更开发出实用的软件系统。不然就是一些不懂领域的人开发出不符合实际的情况的东西，这将造成时间和成本上的浪费。</p>
<ul>
<li>bounted context 限界上下文</li>
<li>core domain 核心领域 common domain 通用领域</li>
<li>domain event 领域事件</li>
<li>domain service 领域服务</li>
<li>聚合根 aggregate root</li>
<li>value object 值对象 entity 实体</li>
<li>infrastructure 基础</li>
<li>module 模块</li>
<li>factory 工厂</li>
<li></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Docker 网络]]></title>
        <id>https://blog.zhuxingzhao.com/post/docker-wang-luo/</id>
        <link href="https://blog.zhuxingzhao.com/post/docker-wang-luo/">
        </link>
        <updated>2019-04-13T15:59:51.000Z</updated>
        <content type="html"><![CDATA[<h4 id="docker网络概述">Docker网络概述</h4>
<p>Docker 作为当下主流容器技术，其网络通信是其中比较重要的一环，Docker实际使用中会遇到如下的情况</p>
<ul>
<li>
<p>单机Docker网络通信</p>
<figure data-type="image" tabindex="1"><img src="https://blog.zhuxingzhao.com/post-images/1623600224477.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>多机Docker网络通信<br>
<img src="https://blog.zhuxingzhao.com/post-images/1623600256205.png" alt="" loading="lazy"></p>
</li>
</ul>
<p>在单机的情况下，Docker提供了5种网络模式供我们选择</p>
<ol>
<li>bridge网络模式</li>
<li>host网络模式</li>
<li>other-container网络模式</li>
<li>none网络模式</li>
<li>自定义模式</li>
</ol>
<blockquote>
<p>docker源码 <code>github.com/docker/docker/api/types/container/hostconfig_unix.go</code></p>
</blockquote>
<p>在源码里我们可以看到几种模式的定义</p>
<pre><code class="language-go">// NetworkName 返回网络栈的名称
func (n NetworkMode) NetworkName() string {
   if n.IsBridge() {
      return &quot;bridge&quot;
   } else if n.IsHost() {
      return &quot;host&quot;
   } else if n.IsContainer() {
      return &quot;container&quot;
   } else if n.IsNone() {
      return &quot;none&quot;
   } else if n.IsDefault() {
      return &quot;default&quot;
   } else if n.IsUserDefined() {
      return n.UserDefined()
   }
   return &quot;&quot;
}
</code></pre>
<p>在多机的情况下Docker的网络互通有以下方式</p>
<ul>
<li>docker网桥实现跨主机连接</li>
<li>Open vSwitch实现跨主机容器连接</li>
<li>使用weave实现跨主机容器连接</li>
<li>等等（还有许多方式的网络互通）</li>
</ul>
<h3 id="docker单机网络">Docker单机网络</h3>
<blockquote>
<p>在开始下面的内容之前，我们先梳理一下docker cli 从执行<code>docker run ….</code>命令到<code>docker daemon</code>的过程中，发生了什么。</p>
<p><code>Dokcer cli</code> 与 <code>Docker daemon</code> 的交互其实是典型的cs模式，而且其中的交互是使用请求（socket, http）的方式进行的，<code>Docker daemon</code>通过开启一个服务器来监听请求，例如<code>docker run ...</code>会发生以下的请求</p>
<p>![未命名表单 (https://blog.zhuxingzhao.com/post-images/1623600316756.png)</p>
<p><code>Dcoker Server</code>是以restful-api的形式管理的,可以看到对container的操作api就可以知道</p>
<pre><code class="language-go">	// HEAD
	router.NewHeadRoute(&quot;/containers/{name:.*}/archive&quot;, r.headContainersArchive),
	// GET
	router.NewGetRoute(&quot;/containers/json&quot;, r.getContainersJSON),
	router.NewGetRoute(&quot;/containers/{name:.*}/export&quot;, r.getContainersExport),
	router.NewGetRoute(&quot;/containers/{name:.*}/changes&quot;, r.getContainersChanges),
	router.NewGetRoute(&quot;/containers/{name:.*}/json&quot;, r.getContainersByName),
	router.NewGetRoute(&quot;/containers/{name:.*}/top&quot;, r.getContainersTop),
	router.NewGetRoute(&quot;/containers/{name:.*}/logs&quot;, r.getContainersLogs),
	router.NewGetRoute(&quot;/containers/{name:.*}/stats&quot;, r.getContainersStats),
	router.NewGetRoute(&quot;/containers/{name:.*}/attach/ws&quot;, r.wsContainersAttach),
	router.NewGetRoute(&quot;/exec/{id:.*}/json&quot;, r.getExecByID),
	router.NewGetRoute(&quot;/containers/{name:.*}/archive&quot;, r.getContainersArchive),
	// POST
	router.NewPostRoute(&quot;/containers/create&quot;, r.postContainersCreate),
	router.NewPostRoute(&quot;/containers/{name:.*}/kill&quot;, r.postContainersKill),
	router.NewPostRoute(&quot;/containers/{name:.*}/pause&quot;, r.postContainersPause),
	router.NewPostRoute(&quot;/containers/{name:.*}/unpause&quot;, r.postContainersUnpause),
	router.NewPostRoute(&quot;/containers/{name:.*}/restart&quot;, r.postContainersRestart),
	router.NewPostRoute(&quot;/containers/{name:.*}/start&quot;, r.postContainersStart),
	router.NewPostRoute(&quot;/containers/{name:.*}/stop&quot;, r.postContainersStop),
	router.NewPostRoute(&quot;/containers/{name:.*}/wait&quot;, r.postContainersWait),
	router.NewPostRoute(&quot;/containers/{name:.*}/resize&quot;, r.postContainersResize),
	router.NewPostRoute(&quot;/containers/{name:.*}/attach&quot;, r.postContainersAttach),
	router.NewPostRoute(&quot;/containers/{name:.*}/copy&quot;, r.postContainersCopy), // Deprecated since 1.8, Errors out since 1.12
	router.NewPostRoute(&quot;/containers/{name:.*}/exec&quot;, r.postContainerExecCreate),
	router.NewPostRoute(&quot;/exec/{name:.*}/start&quot;, r.postContainerExecStart),
	router.NewPostRoute(&quot;/exec/{name:.*}/resize&quot;, r.postContainerExecResize),
	router.NewPostRoute(&quot;/containers/{name:.*}/rename&quot;, r.postContainerRename),
	router.NewPostRoute(&quot;/containers/{name:.*}/update&quot;, r.postContainerUpdate),
	router.NewPostRoute(&quot;/containers/prune&quot;, r.postContainersPrune),
	router.NewPostRoute(&quot;/commit&quot;, r.postCommit),
	// PUT
	router.NewPutRoute(&quot;/containers/{name:.*}/archive&quot;, r.putContainersArchive),
	// DELETE
	router.NewDeleteRoute(&quot;/containers/{name:.*}&quot;, r.deleteContainers)
</code></pre>
<p>以<code>docker run</code>举例<br>
<code>docker cli</code>会进行run 后面的解析</p>
<blockquote>
<p>github.com/docker-ce/components/cli/cli/command/container/opts.go</p>
<p>会有每一个跟container通用选项的源码设置</p>
</blockquote>
<p><code>run</code>命令一些自己的参数设在</p>
<blockquote>
<p>github.com/docker-ce/components/cli/cli/command/container/run.go</p>
</blockquote>
<p>我们可以在源码中看到如下的代码，说明<code>run</code>会首先创建一个<code>container</code></p>
<pre><code class="language-go">createResponse, err := createContainer(ctx, dockerCli, containerConfig, &amp;opts.createOptions)
</code></pre>
<p>然后该函数会会在其中检查opts参数的pull属性判断需不需要拉取<code>images</code>，如果需要就会先执行<code>createContainer</code>定义的一个pullAndTagImages的函数，取发送一个请求拉取一个<code>image</code><br>
随后就会执行真正的<code>dockerCli.Client().ContainerCreate</code>方法将参数传递到<code>Docker Daemon</code>中开始创建一个<code>container</code></p>
<pre><code class="language-go">serverResp, err := cli.post(ctx, &quot;/containers/create&quot;, query, body, nil)
</code></pre>
<p>可以看到<code>dockerCli.Client().ContainerCreate</code>发送了一个<code>post</code>请求到了<code>Docker Daemon</code><br>
然后将我们的目光放到<code>Docker Daemon</code>开启的<code>server</code>中</p>
<blockquote>
<p>github.com/docker-ce/components/engine/api/server/router/container/container.go<br>
从中我们可以看到<code>/containers/create</code>路由的注册</p>
</blockquote>
<pre><code class="language-go">router.NewPostRoute(&quot;/containers/create&quot;, r.postContainersCreate),
</code></pre>
<p>注册的handler函数会执行其中的</p>
<pre><code class="language-go">ccr, err := s.backend.ContainerCreate(types.ContainerCreateConfig{
	Name:             name,
	Config:           config,
	HostConfig:       hostConfig,
	NetworkingConfig: networkingConfig,
	AdjustCPUShares:  adjustCPUShares,
}) 
</code></pre>
<p>将调用实际<code>Docker daemon</code>方法来进行容器的创建</p>
<pre><code class="language-go">func (daemon *Daemon) ContainerCreate(params types.ContainerCreateConfig) (containertypes.ContainerCreateCreatedBody, error) {
return daemon.containerCreate(createOpts{
	params:                  params,
	managed:                 false,
	ignoreImagesArgsEscaped: false})
}
</code></pre>
<p>最终通过一系列的设置网络，layer等最终创建了一个容器并返回给了<code>docker cli</code></p>
<p>随后<code>docker cli</code>会发起<code>start container</code>请求</p>
<pre><code class="language-go">router.NewPostRoute(&quot;/containers/{name:.*}/start&quot;, r.postContainersStart),
</code></pre>
<p>这个handler会进行参数校验后执行</p>
<pre><code class="language-go">s.backend.ContainerStart(vars[&quot;name&quot;], hostConfig, checkpoint, checkpointDir)
</code></pre>
<p>然后最终调用到<code>daemon</code>的<code>containerStart</code>方法去启动一个容器而我们的网络初始化也在这里</p>
</blockquote>
<p>从上文中我们了解到，<code>docker run</code>一个容器的过程中，会发送两个请求到<code>daemon</code>中，第一次创建一个容器，实际上是对一个容器的内存抽象，这里会将各种参数配置进去，当然包括我们的网络配置，第二次请求实际创建了容器，网络的实际的初始化在这个阶段进行。</p>
<h4 id="bridge网络模式">Bridge网络模式</h4>
<blockquote>
<p>在源码中bridge模式，会在<code>create container</code>的过程中配置到抽象的容器实例中，然后在start container的过程中，通过</p>
<pre><code class="language-go">daemon.allocateNetwork(container)
</code></pre>
<p>来分配网络接口设备信息</p>
<p>其中会调用</p>
<pre><code class="language-go">daemon.connectToNetwork(container, defaultNetName, nConf.EndpointSettings, updateSetting)
</code></pre>
<p>该函数会创建相应的<code>sandbox</code>、<code>endpoint</code>然后将<code>endpoint</code>跟<code>sandbox</code>绑定</p>
<blockquote>
<p><strong>Sandbox</strong></p>
</blockquote>
<blockquote>
<p>一个Sandbox包含了一个容器网络栈的配置。其中包括了对容器的网卡，路由表以及对DNS设置的管理。通常，一个Sandbox的实现可以是一个Linux Network Namespace，一个FreeBSD Jail或者其他类似的东西。一个Sandbox可以包含多个处于不同Network的Endpoint。</p>
</blockquote>
<blockquote>
<p><strong>Endpoint</strong></p>
</blockquote>
<blockquote>
<p>Endpoint将一个Sandbox加入一个Network。Endpoint的实现可以是一个veth对，一个Open vSwitch internal port或者其他类似的东西。一个Endpoint只能属于一个Network和一个Sandbox。</p>
</blockquote>
<blockquote>
<p><strong>Network</strong></p>
</blockquote>
<blockquote>
<p>Network是一个能够互相通信的Endpoint的集合。Network的实现可以是一个Linux网桥，一个VLAN等等。</p>
</blockquote>
</blockquote>
<p><code>bridge</code>网络是<code>docker</code>默认的网络模式，该模式为<code>Docker Container</code>创建了一个独立的网络空间，保证容器内的进程组使用独立的网络环境，实现了容期间，容器和主机之间的网络空间隔离。还可以通过host上的网桥(<code>docker0</code>)来连通容器内部的网络空间和host的网络空间，实现容器和host的网络通信，甚至和外网的通信。</p>
<p>Bridge主要通过以下方式实现</p>
<ol>
<li>Docker Daemon 在创建容器时，会在<code>host</code>上创建两个虚拟网络接口设备，例如<code>veth1</code>和<code>veth2</code>，保证一个接受<br>
到的网络报文都能传给另外一方</li>
<li>Docker Daemon 将<code>veth1</code>加到<code>docker1</code>的网桥上，从而转发<code>host</code>的网络报文</li>
<li>将<code>veth1</code>挂到<code>container</code>的网络空间下面，并改为<code>eth0</code>，这样一来就实现了<code>container</code>的网络隔离以及跟<code>host</code>及外网的网络通信</li>
</ol>
<p>如此虽然已经实现了container的网络隔离和网络连通性，但依然无法使外界请求到达<code>container</code>如此我还需要使用NAT的方式，将网络报文发往<code>container</code></p>
<p>所以当<code>container</code>需要暴露服务时，内部的服务是需要监听容器<code>ip</code>和<code>port</code>的，这样才能使用NAT的方式转发到对应的内部服务。在<code>linux</code>上主要使用<code>iptables</code>来进行网络转发（当然需要	<code>linux</code>支持<code>ipv4</code>网络报文转发的能力, 在Docker Daemon启动时，会检查<code>linux</code>是否支持<code>ipv4</code>转发，不能<code>ipv4</code>转发是无法启动Docker Daemon的）</p>
<p>具体<code>iptables</code>如下</p>
<pre><code class="language-bash">iptables -I FORWARD -o docker0 -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
</code></pre>
<p>该模式的有点很明显，隔离了<code>container</code>的网络空间，但时缺点也很明显，在暴露内部服务时，依然依赖于<code>host</code>的端口和公网ip，没有自己独立的<code>ip</code>和<code>port</code>，而且中间经过了转发，是有一定的传输效率的</p>
<h4 id="host网络模式">host网络模式</h4>
<blockquote>
<p>从上文中我们知道，网络初始化在start container的过程中</p>
<p>在<code>initializeNetworking</code>方法中我们可以看到如果是<code>host</code>模式就与<code>host</code>共享网络资源</p>
<pre><code class="language-go">if container.HostConfig.NetworkMode.IsHost() {
   if container.Config.Hostname == &quot;&quot; {
      container.Config.Hostname, err = os.Hostname()
      if err != nil {
         return err
      }
   }
}
</code></pre>
</blockquote>
<p>该模式就如同名字一样，就是共享<code>host</code>的网络空间，并没有为<code>container</code>创建独立的隔离网络环境，所以该模式的<code>container</code>和<code>host</code>一起使用<code>eth0</code>, 即<code>docker</code>的<code>ip</code>和端口，就是<code>host</code>的<code>ip</code>和端口</p>
<figure data-type="image" tabindex="2"><img src="http://blog.daocloud.io/wp-content/uploads/2015/01/Docker_Network_host.jpg" alt="17" loading="lazy"></figure>
<p>在模式下，我们明显脱离了一层nat转发的过程，保证了网络传输的可靠性和传输速度。在对网络环境不要求的一些服务同时又要求网络性能的情况下，该种模式是很有必要的，与bridge模式形成了很好的不出</p>
<h4 id="other-container网络模式">other-container网络模式</h4>
<blockquote>
<p>接上文在<code>initializeNetworking</code>方法中可以看到如果是<code>container</code>就会将该其他容器的网络空间与该容器绑定，从而共享网络空间</p>
<pre><code class="language-go">if container.HostConfig.NetworkMode.IsContainer() {
   // we need to get the hosts files from the container to join
   nc, err := daemon.getNetworkedContainer(container.ID, container.HostConfig.NetworkMode.ConnectedContainer())
   if err != nil {
      return err
   }

   err = daemon.initializeNetworkingPaths(container, nc)
   if err != nil {
      return err
   }

   container.Config.Hostname = nc.Config.Hostname
   container.Config.Domainname = nc.Config.Domainname
   return nil
}
</code></pre>
</blockquote>
<p>这个模式是<code>docker</code>一个特殊的网络模式，在这个模式下的<code>container</code>会借助其他容器的网络环境，之所以称为“特别”，是因为这个模式下容器的网络隔离性会处于<code>bridge</code>桥接模式与<code>host</code>模式之间。<code>Docker Container</code>共享其他容器的网络环境，则至少这两个容器之间不存在网络隔离，而这两个容器又与宿主机以及除此之外其他的容器存在网络隔离。</p>
<figure data-type="image" tabindex="3"><img src="http://blog.daocloud.io/wp-content/uploads/2015/01/Docker_network_other_container.jpg" alt="17" loading="lazy"></figure>
<p>实现该模式只需要将<code>namespace</code>使用<code>other container</code>的<code>namespace</code>即可</p>
<p>在这种模式下的<code>Docker Container</code>可以通过<code>localhost</code>来访问<code>namespace</code>下的其他容器，传输效率较高。虽然多个容器共享网络环境，但是多个容器形成的整体依然与宿主机以及其他容器形成网络隔离。另外，这种模式还节约了一定数量的网络资源。但是需要注意的是，它并没有改善容器与宿主机以外世界通信的情况。</p>
<h4 id="none模式">none模式</h4>
<p>该模式顾名思义，即不设置任何的网络模式，一旦设置改模式，容器内只有lp回环网络，不会再有其他的网络资源。所以相当隔壁，相当的纯粹。</p>
<h4 id="自定义模式">自定义模式</h4>
<p>上文提到<code>docker</code>有<code>none</code>的模式，在此模式，<code>docker</code>对<code>container</code>的网络基本不做任何设置，所以我们可以自定义网络，从而实现我们所面对的业务场景。这也恰巧体现了<code>Docker</code>设计理念的开放。</p>
<h5 id="容器间通信">容器间通信</h5>
<p>通过以上我们了解到了<code>docker</code>的网络模式，我们面对了一个实际场景就是容器之间的通信，因为我们的服务可能是多服务的组成共同对外服务，例如传统的<code>lnmp</code>服务我们需要<code>php</code>、<code>mysql</code>、<code>nginx</code>甚至我们还需要<code>redis</code>的三方服务。这些服务各自为一个容器，我们需要他们互相通信，组成一个服务对外提供。</p>
<p>这里我们主要使用<code>Docker Bridge</code>模式，从前文我们知道在<code>bridge</code>的模式下，我们的<code>container</code>的网络设备与<code>docker0</code>连通，所以我们的<code>eth0</code>会被分配在<code>docker0</code>下面的网络子网，一般为<code>172.17.x.1</code>这个网段下面。</p>
<p>所以我们可以通过以下三种方式</p>
<ol>
<li>
<p>容器的ip通信</p>
<p>我们可以通过<code>docker inspect</code>查询到<code>container</code>到内部ip进行通信，但是这样会导致硬编码，而且从新开启一个<code>container</code>之后ip又变了，也不方便迁移</p>
</li>
<li>
<p>host的端口映射</p>
<p>通过绑定<code>host</code>的<code>ip</code>的<code>port</code>的进行通信，但是依赖于外部端口进行有限的通信，做不到灵活性</p>
</li>
<li>
<p>通过容器名</p>
<p>可以使用容器名，通过<code>docker</code>的<code>link</code>机制通信。这种方式通过<code>docker</code>的<code>link</code>机制可以通过一个name来和另一个容器通信，link机制方便了容器去发现其它的容器并且可以安全的传递一些连接信息给其它的容器。使用name给容器起一个别名，方便记忆和使用。即使容器重启了，地址发生了变化，不会影响两个容器之间的连接</p>
</li>
</ol>
<p>我们主要使用第三种方式进行主机内同学，我们可以使用<code>docker-composer</code>通过<code>docker-compose.yaml</code>定义一个服务，<code>docker-composer</code>能根据配置文件帮我创建一个多容器服务互相通信的应用服务</p>
<p>以下是一个<code>laravel</code>、<code>php</code>、<code>nginx</code>、<code>mysql</code>、<code>redis</code>组成的一个服务通过d<code>ocker-compose.yaml</code>编排</p>
<pre><code>version: '2'

services:
  nginx:
    depends_on:
      - &quot;php&quot;
    image: &quot;nginx&quot;
    restart: unless-stopped
    volumes:
      - &quot;$PWD/deploy/nginx:/etc/nginx/conf.d&quot;
      - &quot;$PWD:/var/www/html&quot;
      - ./data/certbot/conf:/etc/letsencrypt
      - ./data/certbot/www:/var/www/certbot
    ports:
      - &quot;80:80&quot;
      - &quot;443:443&quot;
    networks:
      - app-network
    command: &quot;/bin/sh -c 'while :; do sleep 6h &amp; wait $${!}; nginx -s reload; done &amp; nginx -g \&quot;daemon off;\&quot;'&quot;
  certbot:
    image: certbot/certbot
    restart: unless-stopped
    volumes:
      - ./data/certbot/conf:/etc/letsencrypt
      - ./data/certbot/www:/var/www/certbot
    entrypoint: &quot;/bin/sh -c 'trap exit TERM; while :; do certbot renew; sleep 12h &amp; wait $${!}; done;'&quot;

  php:
    image: &quot;php&quot;
    restart: unless-stopped
    volumes:
      - &quot;$PWD:/var/www/html&quot;
    build:
      context: .
      dockerfile: &quot;Dockerfile&quot;
    working_dir: /var/www/html
#    entrypoint:
#      - ls /var/www/html
#      - chmod +x /var/www/html/deploy/run
#      - /var/www/html/deploy/run
    networks:
      - app-network


  mysql:
    image: mysql:5.7
    volumes:
      - &quot;$PWD/data/mysql:/var/lib/mysql&quot;
    restart: unless-stopped
    environment:
      MYSQL_ROOT_PASSWORD: xxxx
      MYSQL_DATABASE: xxx
      MYSQL_USER: xxxx
      MYSQL_PASSWORD: xxx
    ports:
      - &quot;3306:3306&quot;
    networks:
      - app-network


  redis:
    image: &quot;redis&quot;
    restart: unless-stopped
    ports:
      - &quot;6379:6379&quot;
    networks:
      - app-network
#    volumes:

networks:
  app-network:
    driver: bridge
</code></pre>
<p>从而用<code>docker-compose up</code>即可开启一套容器服务</p>
<blockquote>
<p>参考资料</p>
</blockquote>
<blockquote>
<p>docker 源码解析</p>
</blockquote>
]]></content>
    </entry>
</feed>